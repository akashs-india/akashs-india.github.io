---
title: "Deserialization Vulnerabilities in .Net - Part 2"
sub_title: "A deep dive"
categories:
  - Security
elements:
  - content
  - css
  - formatting
  - html
  - markup
last_modified_at: 2023-01-21T10:16:49-05:00
---

**Note:** Before you go through this you are highly recommended to read [Part 1](https://sharmaakash.com/docs/security/Deserialization-Part-1/ "Part 1")

In part 2 of this series, we will look at understanding how binary formatter serializes and deserializes data. This is only to give you insights into one of the serializers. That way, you no longer would look at the process of serialization and deserialization as a black box. There are various other serializers/deserializers that can be used for similar purposes. We specifically consider binary formatter as it's inherently insecure and learning more about it will help us understand the crux behind deserialization vulnerabilities.

We will also look at the serialized data created by the binary formatter. Understanding this gives us insights into the content of the serialized payload which aids in understanding how one can generate a malicious serialized payload.

## Overview of the serialization and deserialization process

We continue to use the same class used in [Part 1](https://sharmaakash.com/docs/security/Deserialization-Part-1/ "Part 1"). (1) in the image below shows the code of the same class.
In (3) we create an instance of the demo class which is stored in heap memory as an object graph. The last line in (3) also calls the serialization function that can be seen in (4). Post the completion of the serialization process using the binary formatter we end up with the binary byte stream which can then be transported over the network to a different server, sent to another service or stored on disk for later retrieval.

In (5) this data is received at the other end/ read back from the disk and we deserialize the stream to create the objects in memory. Here the process deserializing the data may or may not be the same as the one that serialized the payload and hence may or may have independent address spaces. The memory snips from windbg in (2) and (6) are just for illustration.

<b>Note:</b> Zoom into images for clarity

![Serialization and deserialization flow](/images/DeserializationPart2_Fig1.png)

## Looking at the serialized payload

As mentioned in part one, the serialization and deserialization utilities need to follow a standard while serializing to and deserializing from the serialized payload. For the process of binary serialization, this format/standard is specified in open specification documents that can be downloaded from [here](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-nrbf/75b9fe09-be15-475f-85b8-ae7b7558cfe5 "here")

In this blog, we will look at the binary serialized payload generated by the binary formatter. At a high level, the binary payload is a collection of records. Each record consists of a header indicating the type of record, followed by the actual data in the record.

![Serialized payload records](/images/DeserializationPart2_Fig2.png)

In a slightly more detailed view, the key records that are part of the payload are shown below. The payload always starts with the serialization data header which contains the binary formatter version, etc. Then we have the library header with information about the assembly containing the type being serialized. This is followed by the information about the serialized object, including its type name and the details of its member types - their names, types -- followed by the values of the members.

![Types of record in serialized payload](/images/DeserializationPart2_Fig3.png)

The serialized binary data for our class is shown below:

![Serialized data for test class used](/images/DeserializationPart2_Fig4.png)

The data above is in hex (within the red boundary). In green, you see the same content in ASCII.
For example, consider the green circled part above. The first string "74" is represented in Hex. 74 denotes 8 bytes in total (4 bytes used to represent 7 and 4 bytes used to represent 4). Note that we follow little-endian notation here - so 74 translates to = 7*(16^1) + 4*(16^0) = 116 (which is ASCII for t).
Note that the first column in the figure above shows lines numbers. The actual data is in the red area.

In case you are interested to understand and read through the full content of the payload, look through [this blog](https://stackoverflow.com/questions/3052202/how-to-analyse-contents-of-binary-serialization-stream/30176566#30176566 "this blog"). The same explains what the different bytes mean (it shows the serialized payload for a similar class).

Also sharing a payload when there is a hierarchy of objects below. In this case, the demo class contains an additional member storing another object of the class internalObj. (both class code and corresponding serialized payload below).

![Class having internal class](/images/DeserializationPart2_Fig5.png)

![Serialized data of object having internal object](/images/DeserializationPart2_Fig6.png)

The most interesting thing that you need to notice about the payloads above is that they contain the type of object that has been serialized (testDotNet.Demo, testDotNet.InternalObj, etc). When this payload is deserialized, the binary formatter gets to know the type of object to be created by reading the type from the serialized payload stream. This is also what makes the binary serializer inherently vulnerable. Do hold on to your curiosity - I'll explain the why in part 3.

## Customizing the binary formatter serialization/deserialization process

Before you go over the parts talking about the serialization and deserialization flow in a binary formatter, you can look up the below blog to understand the different serialization/deserialization approaches that the binary formtter supports.

[Binary Serialization (diranieh.com)](http://www.diranieh.com/NETSerialization/BinarySerialization.htm "Binary Serialization (diranieh.com)")

**A very brief summary of the above blog (though recommended to read blog for better clarity)**: You need to mark an object as serializable using the [serializable] annotation (properties/members can also be assigned similar annotations). In the most simple case, the binary formatter will take care of the serialization and deserialization process for you. If you want to define a custom serialization/deserialization behaviour you can have your class implement interfaces ISerializable/IDeserializationCallback. Sometimes you might want to write a custom serialization/deserialization behaviour for a class that you cannot annotate as serializable (say it's a class in an assembly that you don't own). In this case or if you just want to write this custom logic to serialize a class A outside the actual class - you can define a surrogate class for class A, where you can write the custom logic to serialize/deserialize class A. Read through the above-mentioned blog for details. Another way to customize the serialization process is by using binders. A binder allows the implementation of custom methods like BindToName and BindToType, which can be plugged into the serialization process when using a binary formatter. BindToName takes the object type as input and expects the corresponding type and assembly name to be returned as strings outputs. These can then be put into the serialized stream (which contains the type of object being serialized and its assembly). BindToType does the reverse by returning the object type given the name of the type and its assembly as string inputs.

## Serialization flow via binary formatter

In this section, I share details on the serialization flow in the binary formatter based on reading the code in the .net framework. Also, the flow shows details primarily of when you mark the class of the object to be serializable using the [Serializable] annotation.
As mentioned there are other ways in which you can specify custom behaviour/functions to be executed during serialization/deserialization by either defining a surrogate for it or by making the class implement the ISerializable interface.
For below explanantion, we also don't use the binder during serialization/deserialization. 

![Binary formatter serialization flow](/images/DeserializationPart2_Fig7.png)

(1) indicates the creation of the binary formatter and the serializer call that we, as a developer, would write in our code. Post that, the process of serializing the object and writing the corresponding serialized binary payload into the output stream starts (denoted as outputSerializedStream in (1)). The first part of the payload is a serialization header which contains information about the version of the binary formatter used, etc and hence this data is written into the output stream in (2).
In (3), we get the name of the assembly that contains the object we are deserializing and also the object type.

Note that here if you wish to write a custom type into the serialized payload instead of the actual type being serialized, you can do so using a binder that you can pass as input in the new BinaryFormatter() call. You do this by implementing the bindToName method, wherein you will take a type as input param and can return the same type or a type of your choice in the string output (so this gives you control over what you write into the stream). During deserialization too, you have this control wherein you might read type A from the serialized payload but instructor binary formatter to construct type B using the bindToType method. Look at the use case in [this question](https://stackoverflow.com/questions/5794686/serializationbinder-with-listt "need for bindToType") to understand scenarios where this might be needed. 

Post that at (5), the .net code checks if there is a surrogate that has been passed to handle the serialization/deserialization of the object or if the object implements the ISerializable interface. In our case, as none of the above is true, at (8), the code uses reflection to get the different fields in the object, their types and their values. All of this is stored inside a SerObjectInfoCache as shown in step (9). It then goes ahead and writes the info of the assembly and the object being serialized into the serialization output stream. Post that, as shown in (12), it writes all member names, followed by the member types and then the member data of each member. Note that if there are objects inside the first object being deserialized, as shown in (11), we recursively extract the info of the internal objects and then write that data to the stream.

## Deserialization flow using binary formatter

Currently, this section will give a brief of the deserialization process of the object when we don't use the binder/surrogate/ISerializable.

![Binary formatter deserialization flow](/images/DeserializationPart2_Fig8.png)

The diagram above should explain to you the sequence of steps during deserialization. The important thing to note here is that when we use binary formatter, the type of object to be serialized is part of the serialized payload.
The binary formatter picks that type and then creates an uninitialized object out of the same and populates its values. The constructor of the object is not called in the process. 
One thing that we have not shown in the above diagram other than the surrogates is that there are also some event handlers that can be defined in classes to be executed once the deserialization of the corresponding object of that class completes.

Hoping that this blog gave you clarity on the inner workings of serialization and deserialization from the context of the binary formatter. In the next blog we will look through how the deserialization flow can be exploited to carry out attacks like remote code execution.

## References

  1. [Contents of a binary serialized payload](https://stackoverflow.com/questions/3052202/how-to-analyse-contents-of-binary-serialization-stream/30176566#30176566 "this blog")
  2. [Binary Serialization (diranieh.com)](http://www.diranieh.com/NETSerialization/BinarySerialization.htm "Binary Serialization (diranieh.com)")
